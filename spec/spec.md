# Technical Specification for Mina Credentials

This document is a low-level technical specification for the Mina Credentials system.
It is intended as document for the accompanying codebase and implementators.
It does not include security proofs or motivations for the design choices,
see the RFC for such discussions.

# Protocol: Presenting Credentials

The application logic only interacts with the `Credential` struct:

```javascript
Attributes {
  owner: PublicKey,  // the owners public key
  attrs: Attributes, // hidden attributes (e.g. age, name, SSN)
}
```

```javascript
Credential {
  owner: PublicKey,       // the owners public key
  attributes: Attributes, // hidden attributes (e.g. age, name, SSN)
}
```

```javascript
PublicInput {
  context: Field, // context : specified later
  claims: Claims  // application specific public inputs.
}
```

This means that the application logic does not need to know about the underlying cryptographic primitives
and is pluggable between the simple and recursive credentials.
The public input for both credential types is:

The issuing authority is either:

- A hash of a public key for simple credentials.
- A hash of a sequence of public inputs and verification keys for recursive credentials:
binding the credential to a specific verification logic (e.g. a circuit implementing RSA verification) and input (e.g. hash of Google's RSA public key).

## Circuit: Present Simple Credential

A standardized circuit for presenting simple credentials.

The circuit verifies two signatures: one from the issuer and one from the owner.

```javascript
// the private inputs for the circuit
PrivateInput {
  credential: Credential,
  issuerPk: PublicKey,
  issuerSignature: Signature,
  ownerSignature: Signature,
}

// hash the credential
let credHash = Poseidon.hashPacked(Credential, credential);

// verify the credential issuer signature
issuerSignature.verify(issuerPk, credHash);

// convert issuerPK to opaque field element
let issuer = Poseidon.hashWithPrefix(
  "mina-cred:v0:simple",  // sep. the domain of "simple" and "recursive" issuers
  issuerPk
);

// verify the credential owners signature
ownerSignature.verify(owner, [credHash, issuer, context]);

// verify application specific constraints using the standard API
applicationConstraints(
  credential, // hidden attributes/owner
  issuer,     // potentially hidden issuer
  claims,     // application specific public input
)
```

## Circuit: Present Recursive Credential

A standardized circuit for presenting recursive credentials.

The circuit verifies a proof "from" the issuing authority and a signature from the owner.

```javascript
// the private inputs for the circuit
PrivateInput {
  vk: VerificationKey,
  credIdent: Field,
  credProof: Proof,
  credential: Credential,
  ownerSignature: Signature,
}

// hash the credential
let credHash = Poseidon.hashPacked(Credential, credential);

// verify the credential proof
credProof.publicInput.assertEquals([credHash, credIdent]);
credProof.verify(vk).assertEqual(true);

// the issuer is identified by the recursive relation and public input
let issuer = Poseidon.hashWithPrefix(
  "mina-cred:v0:recursive", // sep. the domain of "simple" and "recursive" issuers
  [vk.hash, credIdent]      // identifies the issuing authority / validation logic
);

// verify the credential owners signature
ownerSignature.verify(owner, [credHash, issuer, context]);

// verify application specific constraints using the standard API
applicationConstraints(
  credential, // hidden attributes/owner
  issuer,     // potentially hidden issuer
  claims,     // application specific public input
)
```

# Context Identifiers

The verifier computes the context (out-of-circuit) as:

```javascript
context = Poseidon.hashWithPrefix(
  "mina-cred:v0:context", // for versioning
  [
    vk.hash,  // the verification key hash (of the presentation proof)
    claims,   // the public input (the set of "claims" being presented)
    nonce,    // a random nonce
    verifier, // a URI for the verifiers identifier (see below)
    action,   // the "action" being performed (e.g. login, transaction hash etc.)
  ]
)
```

The nonce MUST be a uniformly random value generated by the prover.

### Web Application

[Uniform Resource Identifier](https://datatracker.ietf.org/doc/html/rfc3986)

```javascript
let verifier = Keccak256.hash("https://example.com/verify");
```

The scheme MUST be `https`.

# Discussion

Discuss the following with Gregor:

1. Should the `issuer` be a struct instead? (e.g. `Issuer { pk: PublicKey, signature: Signature }`)
1. What is the standard way to provide domain-specific for signatures in the Mina ecosystem? should we do:
```
m = Poseidon.hashWithPrefix("mina-cred:v1:", [credHash, issuer, context]);

signature.verifySignedHashV2(message, m);
```
1. Discuss [Nullifiers](https://github.com/o1-labs/o1js/issues/756) in the context of Mina Credentials.

# Example: Merkle-Tree Credential

# Example: RSA Credential

# Example: PKI Credential

# Bearer Credentials to Mina Credentials

In some applications, e.g. zkPassport (ICAO), knowledge of the signed object constitutes the credential.
To reduce the window of attack (e.g. avoid storing passport scans) and bring the credential into the Mina Credentials system,
a public key must be bound to the knowledge of this signed object.
